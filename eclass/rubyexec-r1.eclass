# Copyright 2025 konsolebox
# Distributed under the terms of the GNU General Public License v2

# @ECLASS: rubyexec-r1.eclass
# @MAINTAINER:
# konsolebox <konsolebox@gmail.com>
# @AUTHOR:
# konsolebox <konsolebox@gmail.com>
# @SUPPORTED_EAPIS: 5 6 7 8
# @BLURB: Rubyexec-based installation helper
# @DESCRIPTION:
# This eclass provides helper functions for installing gem binaries
# with rubyexec as their ruby implementation selector.

[[ ${EAPI} == [5678] ]] || die "EAPI needs to be 5, 6, 7 or 8."

inherit get-opt-and-optarg is-var-true

# @ECLASS_VARIABLE: RUBYEXEC_SHEBANG_MAX_LENGTH
# @DESCRIPTION:
# Implied max length of a #! header
: ${RUBYEXEC_SHEBANG_MAX_LENGTH=127}

# @FUNCTION: _rubyexec_all_files_the_same_or_one_file_only
# @USAGE: <file> ...
# @DESCRIPTION:
# Checks if all specified files are the same.
# @RETURN: OK status (0) if all files match or only one file was specified; FAIL status (1) otherwise
# @INTERNAL
_rubyexec_all_files_the_same_or_one_file_only() {
	local first=$1 x
	shift

	for x; do
		cmp -s -- "${first}" "${x}" || return 1
	done

	return 0
}

# @FUNCTION: _rubyexec_priority_sort_impls
# @USAGE: <impl> ...
# @DESCRIPTION:
# Produces a list of ruby implementations sorted by priority
# @INTERNAL
_rubyexec_priority_sort_impls() {
	local impl i
	_sorted_impls=("$1")
	shift

	for impl; do
		if [[ ${impl} == ruby[0-9][0-9] ]]; then
			for i in "${!_sorted_impls[@]}"; do
				if [[ ${_sorted_impls[i]} != ruby[0-9][0-9] ||
						${impl} > "${_sorted_impls[i]}" ]]; then
					_sorted_impls=("${_sorted_impls[@]:0:i}" "${impl}" "${_sorted_impls[@]:i}")
					continue 2
				fi
			done
		fi

		_sorted_impls+=("${impl}")
	done
}

# @FUNCTION: _rubyexec_parse_common_options
# @USAGE: <option|arg> [<optarg>]
# @DESCRIPTION:
# Parses commoon options passed to rubyexec_install_fakegem_binwrapper[s]
# @RETURN: Parsed values to autopick, autoversion, gem_bindir, gem_name or gem_version
# @INTERNAL
_rubyexec_parse_common_options() {
	OPTSHIFT=0

	case $1 in
	--autopick)
		autopick=true
		;;
	--autoversion)
		autoversion=true
		;;
	--gem-bindir|--gem-bindir=*)
		get_opt_and_optarg "$@"
		gem_bindir=${OPTARG}
		;;
	--gem-name|--gem-name=*)
		get_opt_and_optarg "$@"
		gem_name=${OPTARG}
		;;
	--gem-version|--gem-version=*)
		get_opt_and_optarg "$@"
		gem_version=${OPTARG}
		;;
	*)
		return 1
		;;
	esac

	return 0
}

# @FUNCTION: _rubyexec_create_fakegem_binwrapper
# @USAGE: <path> <header> <binary_name> <gem_name> [<gem_version>] [<gem_bindir>]
# @DESCRIPTION:
# Creates a wrapper binary that's to be installed in /usr/bin.
# Autoversion mode is implied if gem_version and gem_bindir aren't specified.
# @INTERNAL
_rubyexec_create_fakegem_binwrapper() {
	local path=$1 header=$2 binary_name=$3 gem_name=$4
	local lines=("${new_header}" "# Generated by rubyexec-r1.eclass")

	if [[ ${5+.} ]]; then
		local gem_version=$5 gem_bindir=$6
		lines+=("load RbConfig::CONFIG['sitelibdir'].gsub('site_ruby', 'gems') + '/gems/${gem_name}-${gem_version}/${gem_bindir}/${binary_name}'")
	else
		lines+=("require 'rubygems'" "load Gem.activate_bin_path('${gem_name}', '${binary_name}')")
	fi

	printf '%s\n' > "${path}" "${lines[@]}" || die "Failed to write binwrapper code to '${path}'."
}

# @FUNCTION: _rubyexec_get_implementations
# @DESCRIPTION:
# Gets implementations
# @RETURN: List of implementations to use to the impls variable
# @INTERNAL
_rubyexec_get_implementations() {
	if declare -f ruby_get_use_implementations >/dev/null; then
		impls=($(ruby_get_use_implementations)) && [[ ${impls+.} ]] || \
			die "Failed to get implementations."
	else
		die "No implementations specified."
	fi
}

# @FUNCTION: _rubyexec_get_rubyexec_arg
# @USAGE: <autopick> <impl> ...
# @DESCRIPTION:
# Gets shebang argument
# Autopick mode allows other non-selected version which are still in the list to be used.
# @RETURN: Shebang argument to the rubyexec_arg variable
# @INTERNAL
_rubyexec_get_rubyexec_arg() {
	local autopick=$1 impls=("${@:2}")

	if [[ ${autopick} == true ]]; then
		_rubyexec_priority_sort_impls "${impls[@]}"
		printf -v rubyexec_arg '%s,' "${_sorted_impls[@]}"
		rubyexec_arg+=--autopick
	else
		printf -v rubyexec_arg '%s,' "${impls[@]}"
		rubyexec_arg=${rubyexec_arg%,}
	fi
}

# @FUNCTION: _rubyexec_validate_header
# @USAGE: <header>
# @DESCRIPTION:
# Validates header
# @INTERNAL
_rubyexec_validate_header() {
	local header_size=${#1}

	[[ ${RUBYEXEC_SHEBANG_MAX_LENGTH} && RUBYEXEC_SHEBANG_MAX_LENGTH -gt 0 ]] || \
		die "Invalid value for RUBYEXEC_SHEBANG_MAX_LENGTH: ${RUBYEXEC_SHEBANG_MAX_LENGTH}"
	[[ header_size -le RUBYEXEC_SHEBANG_MAX_LENGTH ]] || \
		die "Header size exceeds maximum length: ${header_size}"
}

# @FUNCTION: rubyexec_install_fakegem_binwrapper
# @USAGE: <binary_name> <impl> ... [<option> [<optarg>]] ...
# @DESCRIPTION:
# Creates and installs a single binary wrapper
rubyexec_install_fakegem_binwrapper() {
	local binary_name=() gem_name gem_version gem_bindir impls=() autopick=false autoversion=false \
			extglob_was_enabled=false temp _sorted_impls

	shopt -q extglob && extglob_was_enabled=true
	shopt -s extglob || die "Failed to enable ${shpot}."

	gem_version=(${RUBY_FAKEGEM_VERSION+"${RUBY_FAKEGEM_VERSION}"})
	gem_bindir=(${RUBY_FAKEGEM_BINDIR+"${RUBY_FAKEGEM_BINDIR}"})

	while [[ $# -gt 0 ]]; do
		if _rubyexec_parse_common_options "${@:1:2}"; then
			shift "${OPTSHIFT}"
		elif [[ $1 == -* ]]; then
			die "Invalid option: $1"
		elif [[ ${binary_name+.} ]]; then
			impls+=("$1")
		else
			binary_name=$1
		fi

		shift
	done

	gem_name=${gem_name-${RUBY_FAKEGEM_NAME-${binary_name-}}}

	[[ ${binary_name-} == +([[:alnum:]_-]) ]] || die "Binary name invalid or not specified."
	[[ ${gem_name} == +([[:alnum:]_-]) ]] || die "Gem name invalid: ${gem_name}"
	[[ ${autoversion} == true || ${gem_version+.} ]] || die "Gem version not specified."
	[[ ${autoversion} == true || ${gem_bindir+.} ]] || die "Gem bindir not specified."
	[[ ${impls+.} ]] || _rubyexec_get_implementations

	_rubyexec_get_rubyexec_arg "${autopick}" "${impls[@]}"
	new_header="#!${EPREFIX}/usr/bin/rubyexec ${rubyexec_arg}"
	_rubyexec_validate_header "${new_header}"
	temp=${T}/rubyexec_bin-${binary_name}

	if [[ ${autoversion} == true ]]; then
		_rubyexec_create_fakegem_binwrapper "${temp}" "${new_header}" "${binary_name}" "${gem_name}"
	else
		_rubyexec_create_fakegem_binwrapper "${temp}" "${new_header}" "${binary_name}" "${gem_name}"
				"${gem_version}" "${gem_bindir}"
	fi

	exeinto /usr/bin
	newbin "${temp}" "${binary_name}"

	[[ ${extglob_was_enabled} == false ]] && shopt -u extglob
}

# @FUNCTION: rubyexec_install_fakegem_binwrappers
# @USAGE: [<impl> ...] [<option> [<optarg>]] ...
# @DESCRIPTION:
# This either copies raw binary files to /usr/bin with their #! header
# modified or create wrappers similar to the ones created by
# ruby_fakegem_binwrapper depending on whether the binaries are similar
# or not.
#
# Rubyexec may also be skipped if there's only one effective
# implementationand and --no-skip-ruby-exec isn't specified.
#
# The all_fakegem_install function still has to be called before or
# after calling this function and RUBY_FAKEGEM_BINWRAP needs to be set
# to an empty value before calling it.
rubyexec_install_fakegem_binwrappers() {
	local all_binaries allow_direct_copy=false allow_skip_rubyexec=false autopick=false \
			autoversion=false binary binary_name bindirs content extglob_was_enabled=false \
			final_new_header gem_bindir gem_name gem_version globstar_was_enabled=false impls=() \
			new_header rubyexec_arg temp _sorted_impls

	for shopt in extglob globstar; do
		shopt -q "${shopt}" && eval "${shopt}_was_enabled=true"
		shopt -s "${shopt}" || "Failed to enable ${shopt}."
	done

	gem_name=(${RUBY_FAKEGEM_NAME+"${RUBY_FAKEGEM_NAME}"})
	gem_version=(${RUBY_FAKEGEM_VERSION+"${RUBY_FAKEGEM_VERSION}"})
	gem_bindir=(${RUBY_FAKEGEM_BINDIR+"${RUBY_FAKEGEM_BINDIR}"})

	while [[ $# -gt 0 ]]; do
		if _rubyexec_parse_common_options "${@:1:2}"; then
			shift "${OPTSHIFT}"
		elif [[ $1 == --allow-direct-copy ]]; then
			allow_direct_copy=true
		elif [[ $1 == --allow-skip-rubyexec ]]; then
			allow_skip_rubyexec=true
		elif [[ $1 == -* ]]; then
			die "Invalid option: $1"
		else
			impls+=("$1")
		fi

		shift
	done

	[[ ${gem_name-} == +([[:alnum:]_-]) ]] || die "Gem name invalid or not specified."
	[[ ${autoversion} == true || ${gem_version+.} ]] || die "Gem version not specified."
	[[ ${autoversion} == true || ${gem_bindir+.} ]] || die "Gem bindir not specified."

	bindirs=("${D}/"**"/gems/${gem_name}-${gem_version}/${gem_bindir}")
	[[ ${impls+.} ]] || _rubyexec_get_implementations
	[[ ${#impls[@]} -eq "${#bindirs[@]}" ]] || die "Number of implementations don't match bindirs."

	# Use the ruby implementation directly if it's the only implementation and
	# if --allow-skip-rubyexec is specified.

	if [[ ${#impls[@]} -eq 1 && ${allow_skip_rubyexec} == true ]]; then
		new_header="#!${EPREFIX}/usr/bin/ruby${impls}"
	else
		_rubyexec_get_rubyexec_arg "${autopick}" "${impls[@]}"
		new_header="#!${EPREFIX}/usr/bin/rubyexec ${rubyexec_arg}"
		_rubyexec_validate_header "${new_header}"
	fi

	gem_binaries=("${bindirs}"/*)

	for binary in "${bindirs}"/*; do
		binary_name=${binary##*/}
		all_binaries=("${bindirs[@]/%//${binary_name}}")
		temp=${T}/rubyexec_bin-${binary_name}

		[[ ${#all_binaries[@]} -eq ${#impls[@]} ]] || \
			die "Number of matched binaries don't match implementations."

		# Copy the binary itself if it's a script and is identical in all
		# versions, and if --allow-direct-copy is specified.

		if [[ ${allow_direct_cooy} == true ]] &&
				_rubyexec_all_files_the_same_or_one_file_only "${all_binaries[@]}" &&
				IFS=$' \t' read -ra old_header -n128 < "${binary}" &&
				[[ ${old_header} == *"#!"* ]]; then
			if [[ ${old_header} == *ruby* ]]; then
				final_new_header="${new_header} ${old_header[*]:1}"
			elif [[ ${old_header} == "#!" && ${old_header[1]} == *ruby* ]]; then
				final_new_header="${new_header} ${old_header[*]:2}"
			else
				final_new_header=${new_header}
			fi

			content=() # Just make sure it's cleared.
			readarray -s1 -t content < "${bindirs}/${binary_name}" || \
				die "Failed to read '${bindirs}/${binary_name}'."
			printf '%s\n' "${final_new_header}" "${content[@]/%$'\r'}" > "${temp}" || \
				die "Failed to create modified binary."
			rm "${all_binaries[@]}" || die "Failed to remove binaries."

		# Autoversion isn't really sensible to be used here but added anyway for completeness.

		elif [[ ${autoversion} == true ]]; then
			_rubyexec_create_fakegem_binwrapper "${temp}" "${new_header}" "${binary_name}" \
					"${gem_name}"
		else
			_rubyexec_create_fakegem_binwrapper "${temp}" "${new_header}" "${binary_name}" \
					"${gem_name}" "${gem_version}" "${gem_bindir}"
		fi

		exeinto /usr/bin
		newbin "${temp}" "${binary_name}"
	done

	[[ ${extglob_was_enabled} == false ]] && shopt -u extglob
	[[ ${globstar_was_enabled} == false ]] && shopt -u globstar
}
