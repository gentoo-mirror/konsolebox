#!/sbin/openrc-run
# Copyright 1999-2016 Gentoo Foundation
# Distributed under the terms of the GNU General Public License v2

CONFIG_FILE=${CONFIG_FILE:-/etc/tor/torrc}

CHROOT_CHECK=${CHROOT_CHECK:-true}
CHROOT_JCHROOT=${CHROOT_JCHROOT:-false}
CHROOT_JCHROOT_NEW_USER_NS=${CHROOT_JCHROOT_NEW_USER_NS:-false}
CHROOT_JCHROOT_NEW_USER_NS_CHECK_KERNEL=${CHROOT_JCHROOT_NEW_USER_NS_CHECK_KERNEL:-true}
CHROOT_MOUNT_CHECK_TIMEOUT=${CHROOT_MOUNT_CHECK_TIMEOUT:-20}
CHROOT_MOUNT_VAR_LIB_TOR=${CHROOT_MOUNT_VAR_LIB_TOR:-true}
CHROOT_REFRESH_BINARIES=${CHROOT_REFRESH_BINARIES:-true}
CHROOT_UPDATE_DATA_FILES=${CHROOT_UPDATE_DATA_FILES:-true}
CHROOT_UPDATE_TORRC=${CHROOT_UPDATE_TORRC:-true}

# Don't simplify it to '/var/run/tor.pid' because systemd might need it.
PID_FILE=${PID_FILE:-/var/run/tor/tor.pid}

GRACEFUL_STOP=${GRACEFUL_STOP:-false}
GRACEFUL_STOP_TIMEOUT=${GRACEFUL_STOP_TIMEOUT:-60}

VERBOSE=${VERBOSE:-false}

if [ "${VERBOSE}" = true ]; then
	EINFO_VERBOSE=true
	export EINFO_VERBOSE
else
	unset EINFO_VERBOSE
fi

VERBOSE_START_STOP_DAEMON=${VERBOSE_START_STOP_DAEMON:-false}

# See bug #523552, and https://trac.torproject.org/projects/tor/ticket/5525
# Graceful = wait 30 secs or so until all connections are properly closed.
extra_commands="checkconfig"
extra_started_commands="graceful gracefulrestart gracefulstop reload"
description="Anonymizing overlay network for TCP"
description_checkconfig="Check for valid config file."
description_reload="Reload the configuration."
description_graceful="Gracefully restart."
description_gracefulrestart="Gracefully restart."
description_gracefulstop="Gracefully stop."

depend() {
	need net
}

checkconfig() {
	local file="${CONFIG_FILE}"
	[ -n "${CHROOT}" ] && [ ! "${CHROOT_UPDATE_TORRC}" = true ] && file=${CHROOT}/etc/tor/torrc

	ebegin "Checking if configuration file '${file}' is valid"

	if [ ! -f "${file}" ]; then
		eend 1
		eerror "Tor configuration file '${file}' does not exist."
		eerror "You need to setup the file first."
		eerror "Example is in /etc/tor/torrc.sample."
		return 1
	fi

	if ! /usr/bin/tor --verify-config -f "${file}" >/dev/null 2>&1; then
		eend 1
		eerror "File failed with 'tor --verify-config' test."
		return 1
	fi

	eend 0
}

_check_node() {
	local node="$1" type="$2" minor="$3" major="$4"

	if [ ! -"${type}" "${node}" ] || [ ! "$(stat -c '%t %T' "${node}")" = "${minor} ${major}" ]; then
		eerror "Device node ${node} does not exist or is not valid."
		return 1
	fi

	return 0
}

_check_chroot() {
	local __

	for __ in '' /dev /usr/bin /var/lib; do
		checkpath -d -m 0755 -o 0:0 "${CHROOT}$__" || return 1
	done

	for __ in /etc/tor /var/lib/tor; do
		checkpath -d -m 0750 -o tor:tor "${CHROOT}$__" || return 1
	done

	if [ -f "${CHROOT}/etc/tor/torrc" ]; then
		checkpath -f -m 0750 -o tor:tor "${CHROOT}/etc/tor/torrc" || return 1
	fi

	for __ in /var/tmp /tmp; do
		checkpath -d -m 0777 -o 0:0 "${CHROOT}$__" || return 1
	done

	_check_node "${CHROOT}"/dev/null c 1 3 || return 1
	_check_node "${CHROOT}"/dev/random c 1 8 || return 1
	_check_node "${CHROOT}"/dev/urandom c 1 9 || return 1

	return 0
}

_mountpoint() {
	awk '$2 == mp { r = 0; exit 0 } END { exit r }' mp="$1" r=1 /proc/mounts
}

_mount() {
	if [ "$#" -lt 3 ]; then
		eerror "_mount(): Too few arguments."
		return 1
	fi

	local from="$1" to="$2"
	shift 2

	_mountpoint "${to}" && return 0

	ebegin "Mounting ${from} to ${to}"
	mount "${from}" "${to}" "$@"
	eend "$?"
}

_update_torrc() {
	ebegin "Updating ${CHROOT}/etc/tor/torrc based on ${CONFIG_FILE}"
	awk '$1 != "User"' "${CONFIG_FILE}" > "${CHROOT}/etc/tor/torrc"
	eend "$?"
}

_start_stop_daemon() {
	(
		if [ "${VERBOSE_START_STOP_DAEMON}" = true ]; then
			export EINFO_VERBOSE=true
			verbose_opt='--verbose'
		else
			unset EINFO_VERBOSE
			verbose_opt=
		fi

		exec start-stop-daemon ${verbose_opt} "$@"
	)
}

start() {
	checkconfig || return 1

	# '/usr/lib/tmpfiles.d/tor.conf' already has this configured, but let's just add it anyway.
	checkpath -d -m 0750 -o tor:tor /var/run/tor || return 1

	if [ -n "${CHROOT}" ]; then
		if [ -e "${CHROOT}" ] && fuser -s "${CHROOT}"; then
			eerror "Some processes are still accessing ${CHROOT}."
			return 1
		fi

		if [ "${CHROOT_CHECK}" = true ]; then
			_check_chroot || {
				eerror "Your chroot directory '${CHROOT}' is inconsistent."
				eerror "Please run 'emerge --config net-misc/tor' first."
				return 1
			}
		fi

		if [ "${CHROOT_REFRESH_BINARIES}" = true ]; then
			ebegin "Re-copying binaries to ${CHROOT}"

			local libdir="$(ldd /usr/bin/tor | awk -F/ '$1 ~ /=>/ && $2 ~ /^lib/ && NF > 2 { print $2; exit }')"

			if [ ! -f /usr/bin/rcopy ]; then
				eend 1
				eerror "/usr/bin/rcopy does not exist.  Please install sys-apps/rcopy."
				return 1
			fi

			[ "${VERBOSE}" = true ] && QOPT= || QOPT='-q'

			/usr/bin/rcopy ${QOPT} -t "${CHROOT}" -- /usr/bin/tor "${libdir}"/libnss_compat.so.* || {
				eend 1
				eerror "Rcopy failed."
				return 1
			}

			eend 0
		fi

		if [ "${CHROOT_UPDATE_DATA_FILES}" = true ]; then
			ebegin "Updating Tor's data files"

			for __ in hosts host.conf localtime nsswitch.conf resolv.conf; do
				vebegin "Copying /etc/$__ to ${CHROOT}/etc/"

				if cp -- "/etc/$__" "${CHROOT}/etc/"; then
					veend 0
				else
					eend 1
					[ "${VERBOSE}" = false ] && error "Failed to copy /etc/$__ to ${CHROOT}/etc/."
					return 1
				fi
			done

			vebegin "Updating ${CHROOT}/etc/passwd with 'grep --color=never ^tor: /etc/passwd'"

			if grep --color=never ^tor: /etc/passwd > "${CHROOT}/etc/passwd"; then
				veend 0
			else
				eend 1
				[ "${VERBOSE}" = false ] && eerror "Failed to update ${CHROOT}/etc/passwd using 'grep --color=never ^tor: /etc/passwd'."
				return 1
			fi

			vebegin "Updating ${CHROOT}/etc/group with 'grep --color=never ^tor: /etc/group'"

			if grep --color=never ^tor: /etc/group > "${CHROOT}/etc/group"; then
				veend 0
			else
				eend 1
				[ "${VERBOSE}" = false ] && eerror "Failed to update ${CHROOT}/etc/group using 'grep --color=never ^tor: /etc/group'."
				return 1
			fi

			[ "${VERBOSE}" = false ] && eend 0
		fi

		if [ "${CHROOT_UPDATE_TORRC}" = true ]; then
			_update_torrc || return 1
		fi

		if [ "${CHROOT_MOUNT_VAR_LIB_TOR}" = true ]; then
			_mount /var/lib/tor "${CHROOT}/var/lib/tor" -o bind || return 1
		fi

		if [ "${CHROOT_JCHROOT}" = true ]; then
			if [ "${CHROOT_JCHROOT_NEW_USER_NS}" = true ]; then
				if [ "${CHROOT_JCHROOT_NEW_USER_NS_CHECK_KERNEL}" = true ] && [ -r /proc/config.gz ]; then
					zcat /proc/config.gz | grep -q '^CONFIG_USER_NS=[yY]' &>/dev/null || \
						ewarn "Warning: Kernel doesn't seem configured with CONFIG_USER_NS."
				fi

				ebegin "Starting chrooted Tor in new user namespace using /usr/bin/jchroot"

				: > "${PID_FILE}" && chown tor:tor "${PID_FILE}" && \
				_start_stop_daemon --start --background --env HOME=/var/lib/tor --user=tor --group=tor -- \
						/usr/bin/jchroot --new-user-ns --pidfile="${PID_FILE}" "${CHROOT}" -- \
						/usr/bin/tor -f /etc/tor/torrc
			else
				ebegin "Starting chrooted Tor using /usr/bin/jchroot"

				_start_stop_daemon --start --background --pidfile "${PID_FILE}" \
						--make-pidfile --env HOME=/var/lib/tor -- \
						/usr/bin/jchroot --user=tor --group=tor --pidfile="${PID_FILE}" "${CHROOT}" -- \
						/usr/bin/tor -f /etc/tor/torrc
			fi
		else
			ebegin "Starting chrooted Tor using /bin/chroot"

			_start_stop_daemon --start --background --make-pidfile --pidfile "${PID_FILE}" \
					--env HOME=/var/lib/tor -- \
					/bin/chroot --userspec=tor:tor "${CHROOT}" /usr/bin/tor -f /etc/tor/torrc
		fi
	else
		ebegin "Starting Tor"

		_start_stop_daemon --start --name tor --pidfile "${PID_FILE}" \
				--env HOME=/var/lib/tor -- \
				/usr/bin/tor -f /etc/tor/torrc --runasdaemon 1 --PidFile "${PID_FILE}" \
				>/dev/null 2>&1
	fi

	eend "$?"
}

_umount() {
	local dir="$1"

	_mountpoint "${dir}" || return 0

	ebegin "Unmounting ${dir}"
	umount "${dir}"
	eend "$?"
}

_cleanup_chroot() {
	local something_failed=false

	if [ "${CHROOT_MOUNT_VAR_LIB_TOR}" = true ]; then
		if fuser -s "${CHROOT}/var/lib/tor" 2>/dev/null; then
			ebegin "Waiting until all Tor processes are stopped (max. ${CHROOT_MOUNT_CHECK_TIMEOUT} seconds)"
			waited=0

			while
				sleep 1
				waited=$(( waited + 1 ))
				fuser -s "${CHROOT}/var/lib/tor" 2>/dev/null
			do
				if [ "${waited}" -eq "${CHROOT_MOUNT_CHECK_TIMEOUT}" ]; then
					something_failed=true
					eend 1
					break
				fi
			done

			[ "${something_failed}" = false ] && eend 0
		fi

		_umount "${CHROOT}/var/lib/tor" || something_failed=true
	fi

	if [ "${something_failed}" = false ]; then
		if [ -e "${PID_FILE}" ] && ! fuser -s "${PID_FILE}"; then
			ebegin "Removing ${PID_FILE}"
			rm -f -- "${PID_FILE}"
			eend "$?"
			return
		fi

		return 0
	fi

	return 1
}

stop() {
	if [ "${GRACEFUL_STOP}" = true ]; then
		_graceful_stop
		return
	fi

	ebegin "Stopping Tor"
	_start_stop_daemon --stop --pidfile "${PID_FILE}"
	eend "$?" || return 1

	[ -z "${CHROOT}" ] || _cleanup_chroot
}

graceful() {
	gracefulrestart
}

gracefulrestart() {
	_graceful_stop && start
}

_graceful_stop() {
	ebegin "Gracefully stopping Tor (Can take up to ${GRACEFUL_STOP_TIMEOUT} seconds)"

	_start_stop_daemon --progress --stop --signal INT \
			--retry "${GRACEFUL_STOP_TIMEOUT}" --pidfile "${PID_FILE}"

	eend "$?" || return 1

	[ -z "${CHROOT}" ] || _cleanup_chroot
}

gracefulstop() {
	_graceful_stop && /etc/init.d/tor zap
}

reload() {
	if [ ! -f "${PID_FILE}" ]; then
		eerror "${SVCNAME} isn't running"
		return 1
	fi

	checkconfig || return 1

	if [ -n "${CHROOT}" ] && [ "${CHROOT_UPDATE_TORRC}" = true ]; then
		_update_torrc || return 1
	fi

	ebegin "Reloading Tor configuration"
	_start_stop_daemon --signal HUP --pidfile "${PID_FILE}"
	eend "$?"
}
